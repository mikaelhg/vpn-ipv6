{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What and why The objective is to set up a demonstration IPv6-only \"corporate intranet\" type VPN, with services such as secure DNS and NAT64. IPv6-only, because I've seen various disasters relating to IPv4 corporate networks operating in the 10.x.x.x and 192.168.x.x spaces, which many ISP devices in people's homes also use... and merging companies using the same spaces... How to reproduce the demonstration locally In the Vagrantfile , you can find a description of the virtual machines which are automatically created by Vagrant for this demonstration, as well as their local IP addresses, and memory and CPU reservations, which you might want to tweak if necessary. Install VirtualBox and Vagrant vagrant up vagrant ssh home1 , ping fd8d:407b:d075:8a7e::1 and sudo wg show vagrant ssh gateway , ping fd8d:407b:d075:8a7e::5 and sudo wg show Network space Private IPv6 space, RFC-4193. Chosen IPv6 private space https://www.ultratools.com/tools/rangeGenerator Prefix/L: fd Global ID: 8d407bd075 Subnet ID: 8a7e Combine/CID: fd8d:407b:d075:8a7e::/64 IPv6 addresses: fd8d:407b:d075:8a7e::/64:XXXX:XXXX:XXXX:XXXX Start Range: fd8d:407b:d075:8a7e:0:0:0:0 End Range: fd8d:407b:d075:8a7e:ffff:ffff:ffff:ffff No. of hosts: 18446744073709551616 Local development Vagrant , Virtualbox , Ansible . Vagrant and Virtualbox manage local VMs, Ansible provisions them. Boxes: ubuntu/focal64 gusztavvargadr/windows-10 VPN tools WireGuard , ShadowSocks , TAYGA . WireGuard connects VPN clients and VPN servers. ShadowSocks provides a TCP 443 connection for WireGuard. TAYGA provides NAT64 services for connections from the VPN to the outside world. Tools to investigate https://github.com/DNSCrypt/dnscrypt-proxy","title":"What and why"},{"location":"#what-and-why","text":"The objective is to set up a demonstration IPv6-only \"corporate intranet\" type VPN, with services such as secure DNS and NAT64. IPv6-only, because I've seen various disasters relating to IPv4 corporate networks operating in the 10.x.x.x and 192.168.x.x spaces, which many ISP devices in people's homes also use... and merging companies using the same spaces...","title":"What and why"},{"location":"#how-to-reproduce-the-demonstration-locally","text":"In the Vagrantfile , you can find a description of the virtual machines which are automatically created by Vagrant for this demonstration, as well as their local IP addresses, and memory and CPU reservations, which you might want to tweak if necessary. Install VirtualBox and Vagrant vagrant up vagrant ssh home1 , ping fd8d:407b:d075:8a7e::1 and sudo wg show vagrant ssh gateway , ping fd8d:407b:d075:8a7e::5 and sudo wg show","title":"How to reproduce the demonstration locally"},{"location":"#network-space","text":"Private IPv6 space, RFC-4193.","title":"Network space"},{"location":"#chosen-ipv6-private-space","text":"https://www.ultratools.com/tools/rangeGenerator Prefix/L: fd Global ID: 8d407bd075 Subnet ID: 8a7e Combine/CID: fd8d:407b:d075:8a7e::/64 IPv6 addresses: fd8d:407b:d075:8a7e::/64:XXXX:XXXX:XXXX:XXXX Start Range: fd8d:407b:d075:8a7e:0:0:0:0 End Range: fd8d:407b:d075:8a7e:ffff:ffff:ffff:ffff No. of hosts: 18446744073709551616","title":"Chosen IPv6 private space"},{"location":"#local-development","text":"Vagrant , Virtualbox , Ansible . Vagrant and Virtualbox manage local VMs, Ansible provisions them. Boxes: ubuntu/focal64 gusztavvargadr/windows-10","title":"Local development"},{"location":"#vpn-tools","text":"WireGuard , ShadowSocks , TAYGA . WireGuard connects VPN clients and VPN servers. ShadowSocks provides a TCP 443 connection for WireGuard. TAYGA provides NAT64 services for connections from the VPN to the outside world.","title":"VPN tools"},{"location":"#tools-to-investigate","text":"https://github.com/DNSCrypt/dnscrypt-proxy","title":"Tools to investigate"},{"location":"gateway_configuration/","text":"Other gateway configuration We want the gateway to be able to route traffic between VPN clients, so we need to tell the kernel that this is what we want. /etc/sysctl.d/99-wireguard-route.conf: net.ipv6.conf.all.forwarding=1","title":"Other gateway configuration"},{"location":"gateway_configuration/#other-gateway-configuration","text":"We want the gateway to be able to route traffic between VPN clients, so we need to tell the kernel that this is what we want. /etc/sysctl.d/99-wireguard-route.conf: net.ipv6.conf.all.forwarding=1","title":"Other gateway configuration"},{"location":"nat64_dns64/","text":"NAT64 and DNS64 Let's say that your mobile phone is in a IPv6-only network, only has an IPv6 address and IPv6 routing. But you want to connect to some random web service which only has an IPv4 address. How does this work? Well, in your IPv6-only network, you have a special DNS server which resolves the queries of your IPv6-only devices, such as your mobile phone. When you type \"www.example.com\" in your browser, (and unbeknownst to you, behind the scenes \"www.example.com\" only has the IPv4 address 1.2.3.4,) your browser takes that name, and makes a DNS query to first resolve it into a IP address. In our IPv6-only network, we have a special DNS64 proxy, which forwards that query to your ISP's normal DNS server, which responds with 1.2.3.4. However, your special DNS64 proxy now takes the 1.2.3.4 and appends it to a IPv6 address prefix which you've set up for this purpose. Let's say, we translate 1.2.3.4 to XXXX:XXXX:XXXX:XXXX:0102:0304 this way. Now your browser thinks that \"www.example.com\" is located at the IPv6 address XXXX:XXXX:XXXX:XXXX:0102:0304, and therefore tries to open a TCPv6 connection to that IP, port 443 as usual. The other part of this equation is a special NAT64 gateway, which sits between the IPv6 world and the IPv4 world, and can transform a IPv6 packet destinied to XXXX:XXXX:XXXX:XXXX:0102:0304 into a IPv4 packet destinied to 1.2.3.4, as well as perform the usual NAT tricks. You have to set up your network to route all packets which come from your IPv6-only local devices such as your mobile phone, and which are destinied to any XXXX:XXXX:XXXX:XXXX:: address, through that NAT64 gateway. This way, the NAT64 gateway translates packet addresses from IPv6 to IPv4, and from IPv4 to IPv6, using the address spaces which you've reserved for this use, as well as keep track of every TCP connection which has been opened from the IPv6 side to the IPv4 side. I don't know how UDP is handled, as it's stateless. CoreDNS for DNS64 It looks like the by far easiest way to implement DNS64 as well as an VPN-internal name server, will be to use CoreDNS, and install it with Ansible from their GitHub binary releases. The CoreDNS configuration format seems pretty simple. /etc/Corefile poc.vpn { bind fd8d:407b:d075:8a7e::1 hosts poc.vpn.hosts log } . { bind fd8d:407b:d075:8a7e::1 forward . 8.8.8.8 log } /etc/poc.vpn.hosts fd8d:407b:d075:8a7e::1 gateway.poc.vpn fd8d:407b:d075:8a7e::5 home1.poc.vpn","title":"NAT64 and DNS64"},{"location":"nat64_dns64/#nat64-and-dns64","text":"Let's say that your mobile phone is in a IPv6-only network, only has an IPv6 address and IPv6 routing. But you want to connect to some random web service which only has an IPv4 address. How does this work? Well, in your IPv6-only network, you have a special DNS server which resolves the queries of your IPv6-only devices, such as your mobile phone. When you type \"www.example.com\" in your browser, (and unbeknownst to you, behind the scenes \"www.example.com\" only has the IPv4 address 1.2.3.4,) your browser takes that name, and makes a DNS query to first resolve it into a IP address. In our IPv6-only network, we have a special DNS64 proxy, which forwards that query to your ISP's normal DNS server, which responds with 1.2.3.4. However, your special DNS64 proxy now takes the 1.2.3.4 and appends it to a IPv6 address prefix which you've set up for this purpose. Let's say, we translate 1.2.3.4 to XXXX:XXXX:XXXX:XXXX:0102:0304 this way. Now your browser thinks that \"www.example.com\" is located at the IPv6 address XXXX:XXXX:XXXX:XXXX:0102:0304, and therefore tries to open a TCPv6 connection to that IP, port 443 as usual. The other part of this equation is a special NAT64 gateway, which sits between the IPv6 world and the IPv4 world, and can transform a IPv6 packet destinied to XXXX:XXXX:XXXX:XXXX:0102:0304 into a IPv4 packet destinied to 1.2.3.4, as well as perform the usual NAT tricks. You have to set up your network to route all packets which come from your IPv6-only local devices such as your mobile phone, and which are destinied to any XXXX:XXXX:XXXX:XXXX:: address, through that NAT64 gateway. This way, the NAT64 gateway translates packet addresses from IPv6 to IPv4, and from IPv4 to IPv6, using the address spaces which you've reserved for this use, as well as keep track of every TCP connection which has been opened from the IPv6 side to the IPv4 side. I don't know how UDP is handled, as it's stateless.","title":"NAT64 and DNS64"},{"location":"nat64_dns64/#coredns-for-dns64","text":"It looks like the by far easiest way to implement DNS64 as well as an VPN-internal name server, will be to use CoreDNS, and install it with Ansible from their GitHub binary releases. The CoreDNS configuration format seems pretty simple. /etc/Corefile poc.vpn { bind fd8d:407b:d075:8a7e::1 hosts poc.vpn.hosts log } . { bind fd8d:407b:d075:8a7e::1 forward . 8.8.8.8 log } /etc/poc.vpn.hosts fd8d:407b:d075:8a7e::1 gateway.poc.vpn fd8d:407b:d075:8a7e::5 home1.poc.vpn","title":"CoreDNS for DNS64"},{"location":"plantuml-test/","text":"PlantUML test links Chatbot: https://github.com/hubotio/hubot Apps: https://github.com/probot/probot","title":"PlantUML test"},{"location":"plantuml-test/#plantuml-test","text":"","title":"PlantUML test"},{"location":"plantuml-test/#links","text":"Chatbot: https://github.com/hubotio/hubot Apps: https://github.com/probot/probot","title":"links"},{"location":"wireguard/","text":"Wireguard Of course, these keys aren't actually used anywhere, they're just for this local demo, and can be found from the actual repo as well. gateway /etc/wireguard/wg0.conf: [Interface] PrivateKey = GA7JaXAqjG6xKTzBmhB4c2ggqZazZFZt6ywIA3RW6nQ= Address = fd8d:407b:d075:8a7e::1/64 ListenPort = 51820 [Peer] # home1 PublicKey = K+tbD5OWKJeRYGyCFDWigJNieeiz4NRo4Q7BsD+ivwc= AllowedIPs = fd8d:407b:d075:8a7e::5/128 See the difference in the home1 AllowedIPs between the gateway and the client? On the gateway, we're saying /128 and on the peer we're saying /64 . Note that you'll have to manually add all of the peers to the gateway, if you don't allow automatic adds. In the Peer section for home1 , we're explicitly saying that we only allow traffic from that IP to cross from the VPN link to our direction, even if the client tried to route traffic from other IPs through the link. home1 [Interface] PrivateKey = WNVoPZ+/OpPmId9x6RnCBWDbQ/vXaNgHpYyITEa9QU8= Address = fd8d:407b:d075:8a7e::5/64 [Peer] # gateway PublicKey = pl1LI/XQpwQfPmzGN7Xclidsr34W9CGVAc4plbzmg0o= Endpoint = 10.200.1.10:51820 AllowedIPs = fd8d:407b:d075:8a7e::/64 So, on the client, we're setting our VPN IP explicitly in the Interface, and the AllowedIPs in the Peer section means that we allow traffic from those IPs to cross from the VPN to our machine.","title":"Wireguard"},{"location":"wireguard/#wireguard","text":"Of course, these keys aren't actually used anywhere, they're just for this local demo, and can be found from the actual repo as well.","title":"Wireguard"},{"location":"wireguard/#gateway","text":"/etc/wireguard/wg0.conf: [Interface] PrivateKey = GA7JaXAqjG6xKTzBmhB4c2ggqZazZFZt6ywIA3RW6nQ= Address = fd8d:407b:d075:8a7e::1/64 ListenPort = 51820 [Peer] # home1 PublicKey = K+tbD5OWKJeRYGyCFDWigJNieeiz4NRo4Q7BsD+ivwc= AllowedIPs = fd8d:407b:d075:8a7e::5/128 See the difference in the home1 AllowedIPs between the gateway and the client? On the gateway, we're saying /128 and on the peer we're saying /64 . Note that you'll have to manually add all of the peers to the gateway, if you don't allow automatic adds. In the Peer section for home1 , we're explicitly saying that we only allow traffic from that IP to cross from the VPN link to our direction, even if the client tried to route traffic from other IPs through the link.","title":"gateway"},{"location":"wireguard/#home1","text":"[Interface] PrivateKey = WNVoPZ+/OpPmId9x6RnCBWDbQ/vXaNgHpYyITEa9QU8= Address = fd8d:407b:d075:8a7e::5/64 [Peer] # gateway PublicKey = pl1LI/XQpwQfPmzGN7Xclidsr34W9CGVAc4plbzmg0o= Endpoint = 10.200.1.10:51820 AllowedIPs = fd8d:407b:d075:8a7e::/64 So, on the client, we're setting our VPN IP explicitly in the Interface, and the AllowedIPs in the Peer section means that we allow traffic from those IPs to cross from the VPN to our machine.","title":"home1"}]}